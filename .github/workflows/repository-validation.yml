name: Repository Validation & SQL Check

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - '**'

permissions:
  checks: write
  contents: read
  pull-requests: write

jobs:
  repository-validation:
    name: Repository Validation
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: spawn_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-maven-

      - name: Install repository validation dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client ripgrep

      - name: Repository Static Analysis
        run: |
          echo "üîç Running Repository Static Analysis..."
          
          # Check for common repository naming issues
          echo "Checking for potential naming issues in repository files..."
          find src/main/java -name "*Repository*.java" -exec bash -c '
            echo "üìÅ Analyzing: $1"
            
            # Check for inconsistent parameter naming
            if grep -n "@Param" "$1" | grep -v -E "@Param\(\"[a-zA-Z][a-zA-Z0-9_]*\"\)" ; then
              echo "‚ùå Warning: Inconsistent parameter naming in $1"
              exit 1
            fi
            
            # Check for potential SQL injection vulnerabilities (string concatenation in queries)
            if grep -n "SELECT.*+.*FROM\|UPDATE.*+.*SET\|DELETE.*+.*FROM" "$1" ; then
              echo "‚ùå Warning: Potential SQL injection risk (string concatenation) in $1"
              exit 1
            fi
            
            # Check for missing @Repository annotation
            if ! grep -q "@Repository" "$1" ; then
              echo "‚ùå Warning: Missing @Repository annotation in $1"
              exit 1
            fi
            
            # Check for proper interface naming convention
            filename=$(basename "$1")
            if [[ "$filename" =~ ^I.*Repository\.java$ ]] ; then
              interface_name=$(grep -o "public interface [A-Za-z]*" "$1" | awk "{print \$3}")
              expected_name=$(basename "$1" .java)
              if [ "$interface_name" != "$expected_name" ] ; then
                echo "‚ùå Warning: Interface name $interface_name does not match filename $expected_name in $1"
                exit 1
              fi
            fi
            
            echo "‚úÖ $1 passed static analysis"
          ' _ {} \;

      - name: JPQL Syntax Validation
        run: |
          echo "üîç Checking JPQL syntax patterns..."
          
          # Check for common JPQL mistakes
          find src/main/java -name "*Repository*.java" -exec bash -c '
            echo "üìÅ Checking JPQL in: $1"
            
            # Check for Java-style equality operators in JPQL (== instead of =)
            if grep -n "@Query.*==" "$1" ; then
              echo "‚ùå ERROR: Found Java-style equality operator (==) in JPQL query in $1:"
              echo "JPQL uses single = for equality comparison, not double =="
              grep -n "@Query.*==" "$1" | while read -r line; do
                echo "  Line: $line"
              done
              exit 1
            fi
            
            # Check for Java-style inequality operators in JPQL (!= instead of <>)
            if grep -n "@Query.*!=" "$1" ; then
              echo "‚ùå ERROR: Found Java-style inequality operator (!=) in JPQL query in $1:"
              echo "JPQL uses <> for inequality comparison, not !="
              grep -n "@Query.*!=" "$1" | while read -r line; do
                echo "  Line: $line"
              done
              exit 1
            fi
            
            # Check for improper JOIN syntax
            if grep -n "@Query.*JOIN.*ON.*=" "$1" | grep -v "JOIN FETCH" ; then
              echo "‚ùå Warning: Potentially incorrect JOIN syntax (should use implicit joins in JPQL) in $1:"
              grep -n "@Query.*JOIN.*ON.*=" "$1"
              exit 1
            fi
            
            # Check for missing table aliases in complex queries
            if grep -n "@Query.*SELECT.*FROM.*WHERE.*\." "$1" | grep -v -E "(a\.|u\.|uft\.|au\.|ft\.|c\.)" ; then
              echo "‚ùå Warning: Complex query without proper table aliases in $1"
              exit 1
            fi
            
            # Check for SQL keywords used incorrectly in JPQL context
            if grep -n "@Query.*LIMIT\|@Query.*OFFSET" "$1" ; then
              echo "‚ùå Warning: Found SQL LIMIT/OFFSET in JPQL query in $1:"
              echo "Use Pageable parameter or setMaxResults() instead"
              grep -n "@Query.*LIMIT\|@Query.*OFFSET" "$1"
              exit 1
            fi
            
            # Check for parameter consistency
            query_params=$(grep -o "@Param(\"[^\"]*\")" "$1" | sed "s/@Param(\"\([^\"]*\"))/\1/g" | sort)
            used_params=$(grep -o ":[a-zA-Z][a-zA-Z0-9_]*" "$1" | sed "s/://g" | sort)
            
            if [ -n "$query_params" ] && [ -n "$used_params" ] ; then
              if [ "$query_params" != "$used_params" ] ; then
                echo "‚ùå Warning: Parameter mismatch between @Param and usage in $1"
                echo "Declared params: $query_params"
                echo "Used params: $used_params"
                exit 1
              fi
            fi
            
            # Check for common JPQL reserved word issues
            if grep -n "@Query.*\sorder\s.*=" "$1" | grep -v "ORDER BY" ; then
              echo "‚ùå Warning: Possible confusion between ORDER BY clause and property named order in $1"
              exit 1
            fi
            
            echo "‚úÖ $1 passed JPQL validation"
          ' _ {} \;

      - name: Database Schema Consistency Check
        run: |
          echo "üîç Checking native SQL queries for potential schema issues..."
          
          find src/main/java -name "*Repository*.java" -exec bash -c '
            if grep -q "nativeQuery = true" "$1" ; then
              echo "üìÅ Checking native SQL in: $1"
              
              # Extract native SQL queries and check for common issues
              grep -A 10 "nativeQuery = true" "$1" | grep -o "\"[^\"]*\"" | while read -r query; do
                # Remove quotes
                clean_query=$(echo "$query" | sed "s/^\"\|\"$//g")
                
                # Check for inconsistent naming conventions
                if echo "$clean_query" | grep -i -E "(userId|user_id)" | grep -q -E "userId.*user_id|user_id.*userId" ; then
                  echo "‚ùå Warning: Inconsistent column naming (camelCase vs snake_case) in $1"
                  echo "Query: $clean_query"
                  exit 1
                fi
                
                # Check for potential foreign key naming issues
                if echo "$clean_query" | grep -i -E "_id" | grep -v -E "(user_id|friend_id|tag_id|activity_id|owner_id)" ; then
                  echo "‚ö†Ô∏è  Notice: Uncommon foreign key naming pattern in $1"
                  echo "Query: $clean_query"
                fi
              done
              
              echo "‚úÖ $1 passed native SQL validation"
            fi
          ' _ {} \;

      - name: Spring Boot Context Validation
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/spawn_test
          SPRING_DATASOURCE_USERNAME: testuser
          SPRING_DATASOURCE_PASSWORD: testpassword
          SPRING_JPA_HIBERNATE_DDL_AUTO: validate
          SPRING_PROFILES_ACTIVE: test
        run: |
          echo "üöÄ Validating Spring Boot context and JPA repository queries..."
          
          # Create a minimal test to validate Spring context and repository queries
          cat > src/test/java/com/danielagapov/spawn/RepositoryValidationTest.java << 'EOF'
          package com.danielagapov.spawn;
          
          import org.junit.jupiter.api.Test;
          import org.springframework.boot.test.context.SpringBootTest;
          import org.springframework.test.context.ActiveProfiles;
          import org.springframework.test.context.TestPropertySource;
          
          @SpringBootTest
          @ActiveProfiles("test")
          @TestPropertySource(properties = {
              "spring.jpa.hibernate.ddl-auto=create-drop",
              "spring.jpa.show-sql=true",
              "spring.jpa.properties.hibernate.format_sql=true"
          })
          public class RepositoryValidationTest {
              
              @Test
              public void contextLoads() {
                  // This test will fail if there are any JPQL syntax errors
                  // Spring will validate all @Query annotations during context initialization
              }
          }
          EOF
          
          echo "üìù Running Spring Boot context validation test..."
          mvn test -Dtest="RepositoryValidationTest" -Dfailsafe.useSystemClassLoader=false
          
          # Clean up the temporary test file
          rm -f src/test/java/com/danielagapov/spawn/RepositoryValidationTest.java
          
          echo "‚úÖ Spring Boot context validation completed successfully"

      - name: Build and Test Repository Layer
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/spawn_test
          SPRING_DATASOURCE_USERNAME: testuser
          SPRING_DATASOURCE_PASSWORD: testpassword
          SPRING_JPA_HIBERNATE_DDL_AUTO: create-drop
          SPRING_PROFILES_ACTIVE: test
        run: |
          echo "üöÄ Building project and running repository tests..."
          
          # Compile the project
          mvn clean compile -DskipTests
          
          # Check if repository or persistence test files exist
          if find src/test/java -name "*Repository*Test.java" -o -name "*Persistence*Test.java" | grep -q "."; then
            echo "üìù Found repository/persistence tests, running them..."
            mvn test -Dtest="**/*Repository*Test,**/*Persistence*Test"
          else
            echo "üìù No repository/persistence tests found, skipping test execution..."
            echo "‚úÖ This is expected if you haven't created repository tests yet"
          fi
          
          echo "‚úÖ Repository layer compilation and basic tests completed"

      - name: Repository Method Naming Convention Check
        run: |
          echo "üîç Checking JPA method naming conventions..."
          
          find src/main/java -name "*Repository*.java" -exec bash -c '
            echo "üìÅ Checking method names in: $1"
            
            # Extract method declarations
            grep -n "List<\|Optional<\|boolean \|void \|int \|long " "$1" | grep -v "@Query" | while read -r line; do
              method_name=$(echo "$line" | grep -o "[a-zA-Z][a-zA-Z0-9]*(" | sed "s/(//g")
              
              if [ -n "$method_name" ] ; then
                # Check for proper JPA method naming conventions
                if ! echo "$method_name" | grep -E "^(find|get|exists|count|delete|save|update)" ; then
                  echo "‚ö†Ô∏è  Notice: Method $method_name might not follow JPA naming conventions in $1"
                fi
                
                # Check for potential typos in common JPA keywords
                if echo "$method_name" | grep -i -E "(finde|gett|exist|deletee)" ; then
                  echo "‚ùå Warning: Potential typo in method name $method_name in $1"
                  exit 1
                fi
              fi
            done
            
            echo "‚úÖ $1 passed method naming validation"
          ' _ {} \;

      - name: Generate Repository Validation Report
        if: always()
        run: |
          echo "üìä Generating Repository Validation Summary..."
          
          total_repos=$(find src/main/java -name "*Repository*.java" | wc -l)
          echo "Total repository interfaces analyzed: $total_repos"
          
          # Count different types of queries
          jpql_queries=$(grep -r "@Query(" src/main/java --include="*Repository*.java" | grep -v "nativeQuery = true" | wc -l)
          native_queries=$(grep -r "nativeQuery = true" src/main/java --include="*Repository*.java" | wc -l)
          jpa_methods=$(grep -r "List<\|Optional<\|boolean " src/main/java --include="*Repository*.java" | grep -v "@Query" | wc -l)
          
          echo "JPQL queries found: $jpql_queries"
          echo "Native SQL queries found: $native_queries"
          echo "JPA method declarations found: $jpa_methods"
          
          echo "‚úÖ Repository validation completed successfully!"

      - name: Upload Validation Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: repository-validation-results
          path: |
            target/surefire-reports/
            *.log 